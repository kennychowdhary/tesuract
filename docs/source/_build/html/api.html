

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API &mdash; tesuract 1.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/style.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Some other usage cases" href="tutorials/tutorial02.html" />
    <link href="_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> tesuract
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Main features</a></li>
<li class="toctree-l1"><a class="reference internal" href="guide.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorials/tutorial01.html">Introduction to polynomial regression</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tutorials/tutorial01.html#setup-the-problem">Setup the problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorials/tutorial01.html#fit-a-polynomial">Fit a polynomial</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorials/tutorial01.html#feature-importance">Feature importance</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorials/tutorial01.html#prediction">Prediction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tutorials/tutorial01.html#scale-error">Scale error</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="tutorials/tutorial01.html#different-fit-algorithms">Different fit algorithms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tutorials/tutorial02.html">Some other usage cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tutorials/tutorial02.html#defining-custom-coefficient-array">Defining custom coefficient array</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorials/tutorial02.html#custom-multiindex-array">Custom multiindex array</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorials/tutorial02.html#custom-multiindex-and-coefficient-array">Custom multiindex and coefficient array</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorials/tutorial02.html#using-normalized-legendre-basis">Using normalized Legendre basis</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pce-base-class">PCE Base Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pce-regression-class">PCE Regression Class</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">tesuract</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api">
<span id="id1"></span><h1>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="pce-base-class">
<h2>PCE Base Class<a class="headerlink" href="#pce-base-class" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="tesuract.PCEBuilder">
<em class="property">class </em><code class="sig-prename descclassname">tesuract.</code><code class="sig-name descname">PCEBuilder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">customM</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mindex_type</span><span class="o">=</span><span class="default_value">'total_order'</span></em>, <em class="sig-param"><span class="n">coef</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">a</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">b</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">polytype</span><span class="o">=</span><span class="default_value">'Legendre'</span></em>, <em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">store_phi</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">input_range</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEBuilder" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for building a multivariate polynomial basis.</p>
<p>This class creates a multi-variate polynomial object, aka as a polynomial
chaos model. The expansion looks like</p>
<div class="math notranslate nohighlight">
\[\sum_{i=1}^N c_i \Phi_i(\mathbf{x})\]</div>
<p>where <span class="math notranslate nohighlight">\(N\)</span> is the number of polynomial terms, and
<span class="math notranslate nohighlight">\(\Phi_i:\mathbf{x} \in \mathbb{R}^d \mapsto \mathbb{R}\)</span> is the
multivariate basis function which takes the form</p>
<div class="math notranslate nohighlight">
\[\Phi_i = \prod_{j=1}^d L_{\alpha_j^{(i)}}(x_i),\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha_j\)</span> is an integer tuple of size <span class="math notranslate nohighlight">\(d\)</span> which
represents the multiindex, and <span class="math notranslate nohighlight">\(L:\mathbb{R} \mapsto \mathbb{R}\)</span> are
the one-dimensional Legendre polynomials. So for example, in two dimensions,
we can have <span class="math notranslate nohighlight">\(\Phi_i = xy\)</span>. The construction of the multiindex is done
behind the scenes in the <code class="docutils literal notranslate"><span class="pre">multindex</span></code> module.</p>
<p>Below we list the parameters to construct the object followed by the class
attributes and returns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, default=1</span></dt><dd><p>Description of the order of the polynomials in the
expansion. For total order, the order is the maximum polynomial order
for each basis function per dimension.</p>
</dd>
<dt><strong>customM</strong><span class="classifier">numpy.ndarray, default=None</span></dt><dd><p>An integer numpy aray of size (# of basis functions, # of dimensions). Each
row represents the basis function and each column represents the order of
the 1d polynomial, <span class="math notranslate nohighlight">\(L_i\)</span>.</p>
</dd>
<dt><strong>mindex_type</strong><span class="classifier">{‘total_order’, ‘hyperbolic’}, default=’total_order’</span></dt><dd><p>Different types of multiindex generators. Total order produces basis vectors
that have a maximum order as defined by <strong>order</strong>. Hyperbolic order is
similar but generates fewer cross terms.</p>
</dd>
<dt><strong>coef</strong><span class="classifier">numpy.ndarray, default=None</span></dt><dd><p>1d numpy coefficient array if defining polynomial. Must be the same length
as the number of basis elements, i.e. length of multiindex array.</p>
</dd>
<dt><strong>polytype</strong><span class="classifier">{‘Legendre’}, default=’Legendre’</span></dt><dd><p>A string representing the type of polynomial. So far we only include
Legendre polynomial construction defined on [-1,1]</p>
</dd>
<dt><strong>normalized</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether or not to use normalized polynomials such that
<span class="math notranslate nohighlight">\(\int_{-1}^{1}L_i(x)dx = 1\)</span> or <span class="math notranslate nohighlight">\(\frac{2}{2n+1}\)</span> if True or False, respecively, where
<span class="math notranslate nohighlight">\(n\)</span> is the order of the polynomial (only for Legendre polynomials).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>Dimension of the polynomial, defined after construction.</p>
</dd>
<dt><strong>mindex</strong><span class="classifier">ndarray of shape (nbasis, dim)</span></dt><dd><p>Integer array of the multiindex which describes the structure of the
polynomial basis.</p>
</dd>
<dt><strong>nPCTerms</strong><span class="classifier">int</span></dt><dd><p>The number of basis terms of the multi-variate polynomial.</p>
</dd>
<dt><strong>coef</strong><span class="classifier">ndarray of shape (nbasis,)</span></dt><dd><p>Coefficient array</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As of now, the base class requires the input range to be on the default
range <span class="math notranslate nohighlight">\([-1,1]\)</span> for all dimensions. We have included a useful
preprocessing utility (<code class="docutils literal notranslate"><span class="pre">DomainScaler</span></code>) to transform the domain easily to
the canonical target range from any input range. In the future this will be
an option in the this class.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tesuract</span> <span class="kn">import</span> <span class="n">PCEBuilder</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PCEBuilder</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">mindex</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tesuract.PCEBuilder.compile" title="tesuract.PCEBuilder.compile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compile</span></code></a>(dim)</p></td>
<td><p>Setup for instantiating the basis class</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tesuract.PCEBuilder.computeMoments" title="tesuract.PCEBuilder.computeMoments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">computeMoments</span></code></a>([c])</p></td>
<td><p>Methods to compute the mean and variance of the resulting polynomial</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tesuract.PCEBuilder.computeSobol" title="tesuract.PCEBuilder.computeSobol"><code class="xref py py-obj docutils literal notranslate"><span class="pre">computeSobol</span></code></a>([c])</p></td>
<td><p>Compute Sobol total order variance based sensitivity indices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tesuract.PCEBuilder.eval" title="tesuract.PCEBuilder.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>([X, c])</p></td>
<td><p>Duplicate of polyeval</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tesuract.PCEBuilder.fit_transform" title="tesuract.PCEBuilder.fit_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code></a>(X)</p></td>
<td><p>Fit and transform the given <span class="math notranslate nohighlight">\(X\)</span> coordinates to the polynomial space.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tesuract.PCEBuilder.polyeval" title="tesuract.PCEBuilder.polyeval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polyeval</span></code></a>([X, c])</p></td>
<td><p>Method to evaluate the polynomial.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 68%" />
<col style="width: 32%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>computeJointSobol</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tesuract.PCEBuilder.compile">
<code class="sig-name descname">compile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEBuilder.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup for instantiating the basis class</p>
<p>Constructs the multi-dimensional multi-index which defines the
polynomial basis elements. Note that this is only done once during the
fit method of the class, unless the mindex variable is undefined.</p>
<p>The multi-index array is of size <span class="math notranslate nohighlight">\(N \times dim\)</span> where <span class="math notranslate nohighlight">\(N\)</span>
is the number of basis elements. The multi-index determine the order or
degree of the univariate polynomial in</p>
<div class="math notranslate nohighlight">
\[\Phi_i = \prod_{j=1}^d L_{\alpha_j^{(i)}}(x_i).\]</div>
<p>So for example, <span class="math notranslate nohighlight">\(\alpha_j=2\)</span> corresponds to a second order or
quadratic Legendre polynomial.</p>
<p>Lastly, this method also defines the number of basis elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>dimension of the polynomials</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>self: object</dt><dd><p>Returns the object itself.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tesuract.PCEBuilder.fit_transform">
<code class="sig-name descname">fit_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEBuilder.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit and transform the given <span class="math notranslate nohighlight">\(X\)</span> coordinates to the polynomial
space.</p>
<p>This method essentially performs a high dimensional kernel mapping onto
a polynomial space spanned by the Legendre polynomials. This is similar
to sklearn’s PolynomialFeatures, except here the features are
multi-variate Legendre; the big difference being that the features are
uncorrelated.</p>
<p>Alternatively, the resulting</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">numpy.ndarray of shape (nsamples, dim)</span></dt><dd><p>feature matrix where each row is a sample of the feature space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Phi</strong><span class="classifier">numpy.ndarray of shape (nsamples, nPCTerms)</span></dt><dd><p>returns the polynomial feature map that transforms each sample in <span class="math notranslate nohighlight">\(X\)</span> of dimension <span class="math notranslate nohighlight">\(d\)</span> to dimension <span class="math notranslate nohighlight">\(nPCTerms\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tesuract.PCEBuilder.polyeval">
<code class="sig-name descname">polyeval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">c</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEBuilder.polyeval" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to evaluate the polynomial.</p>
<p>Evaluates the polynomial for a given set of coefficients and data
points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">numpy.ndarray of shape (nsamples, dim)</span></dt><dd><p>feature matrix where each row is a sample of the feature space.</p>
</dd>
<dt><strong>c</strong><span class="classifier">numpy.ndarray of shape (nPCTerms,) (optional)</span></dt><dd><p>coefficient array. The evaluation is simply np.dot(Phi,c). The coefficient array can also be internally set so that it does not need to be fed in each time we need to evaluate the polynomial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>yeval</strong><span class="classifier">numpy.ndarray of shape (X.shape[0],)</span></dt><dd><p>The scalar outputs of the multivariate polynomial evaluated at the feature matrix data points.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tesuract.PCEBuilder.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">c</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEBuilder.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate of polyeval</p>
</dd></dl>

<dl class="py method">
<dt id="tesuract.PCEBuilder.computeSobol">
<code class="sig-name descname">computeSobol</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">c</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEBuilder.computeSobol" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Sobol total order variance based sensitivity indices</p>
<p>Depending on the Legendre polynomial type (normalized vs non-normalized)
the formula will be different. The total order sensitivity is given by</p>
<div class="math notranslate nohighlight">
\[S_i = \sum_{k} \gamma^{-2}_{\beta^i_k} c^2_{\beta^i_k}\]</div>
<p>where <span class="math notranslate nohighlight">\(\{\beta^i_k\}_{k=\dots}\)</span> are the indices that contain at
least the <span class="math notranslate nohighlight">\(i^{th}\)</span> dimension, and <span class="math notranslate nohighlight">\(\gamma\)</span> is the square root norm of that particular basis polynomial (which is 1 for the normalized case).</p>
<p>For this method, we return the normalized Sobol indices, i.e.</p>
<div class="math notranslate nohighlight">
\[T_i \doteq S_i/S_{T}\]</div>
<p>where <span class="math notranslate nohighlight">\(S_{T}\)</span> is the total variance, i.e. <span class="math notranslate nohighlight">\(\{\beta^i_k\}_{k=\dots}\)</span> are the entire set of basis functions. Thus, the total order sensitivity indices are always less than 1, although their sum can be greater than <span class="math notranslate nohighlight">\(S_{T}\)</span>.</p>
<p>This is another advantage of using the Legendre polynomials, in that they are uncorrelated so that their feature importance calculations are very easy to compute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c</strong><span class="classifier">numpy.ndarray of shape (nPCTerms,)</span></dt><dd><p>coefficient to determine the Sobol indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>T</strong><span class="classifier">numpy.ndarray of shape (dim,)</span></dt><dd><p>The total order Sobol sensitivity indices for each dimension</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tesuract.PCEBuilder.computeMoments">
<code class="sig-name descname">computeMoments</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">c</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEBuilder.computeMoments" title="Permalink to this definition">¶</a></dt>
<dd><p>Methods to compute the mean and variance of the resulting polynomial</p>
<p>Assuming a uniform distribution over <span class="math notranslate nohighlight">\([-1,1]\)</span>, this method
computes the mean and variance. The mean is the coefficient of the
<span class="math notranslate nohighlight">\(0^{th}\)</span> order term, while the variance is the weighted sum of
squares of the other coefficients. The weighted sum is determined by
using either the normalized or non-normalized Legendre polynomials.
Finally, the weight is scaled by .5 correpsonding to the density
function for the uniform distribution on the previously stated domain.</p>
<div class="math notranslate nohighlight">
\[\mu = \frac{1}{2} c_0\]</div>
<div class="math notranslate nohighlight">
\[\sigma^2 = \frac{1}{2} \sum_{i=1}^N \gamma^2_i c^2_i \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c</strong><span class="classifier">numpy.ndarray of shape (nPCTerms, )</span></dt><dd><p>coefficient of the polynomial basis. Must have the same number of elements as the number of basis elements.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mu, var</strong><span class="classifier">float,float</span></dt><dd><p>mean and variance floating point values</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pce-regression-class">
<h2>PCE Regression Class<a class="headerlink" href="#pce-regression-class" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="tesuract.PCEReg">
<em class="property">class </em><code class="sig-prename descclassname">tesuract.</code><code class="sig-name descname">PCEReg</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">customM</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mindex_type</span><span class="o">=</span><span class="default_value">'total_order'</span></em>, <em class="sig-param"><span class="n">coef</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">a</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">b</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">polytype</span><span class="o">=</span><span class="default_value">'Legendre'</span></em>, <em class="sig-param"><span class="n">fit_type</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">fit_params</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">store_phi</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">input_range</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEReg" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for performing multivariate polynomial regression</p>
<p>This class fits the coefficients of a a multivariate polynomial object, aka
as a polynomial chaos model, using different linear regression algorithms
from sklearn. Given labeled data pairs <span class="math notranslate nohighlight">\((x_j,y_j)\)</span> for
<span class="math notranslate nohighlight">\(j=1,\dots,n\)</span>, where <span class="math notranslate nohighlight">\(x_j \in \mathbb{R}^d\)</span> and <span class="math notranslate nohighlight">\(y_j \in
\mathbb{R}\)</span>, we look for</p>
<div class="math notranslate nohighlight">
\[\text{arg} \min_{c} \sum_{j}d\left(f(\mathbf{x}_j;c),y_j\right) + \text{Regularizer}(c)\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> is the polynomial model with unknown coefficient parameters, i.e.,</p>
<div class="math notranslate nohighlight">
\[f(\mathbf{x}_j;c) \doteq \sum_{i=1}^N c_i \Phi_i(\mathbf{x}_j)\]</div>
<p>where <span class="math notranslate nohighlight">\(d\)</span> is the error metric, which is typically a squared error, and the regularizer can be either <span class="math notranslate nohighlight">\(\ell_1\)</span> (lasso), <span class="math notranslate nohighlight">\(\ell_2\)</span> (ridge), or both (elastic net). Again, we note that the input must be on <span class="math notranslate nohighlight">\([-1,1]\)</span> for now since the polynomials are setup on that domain by default. One may use sklearn’s preprocessing utilities to make that transformation or use the DomainScaler class that comes with this library.</p>
<p>Below we list the parameters to construct the object followed by the class
attributes and returns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, default=2</span></dt><dd><p>Description of the order of the polynomials in the
expansion. For total order, the order is the maximum polynomial order
for each basis function per dimension.</p>
</dd>
<dt><strong>customM</strong><span class="classifier">numpy.ndarray, default=None</span></dt><dd><p>An integer numpy aray of size (# of basis functions, # of dimensions). Each
row represents the basis function and each column represents the order of
the 1d polynomial, <span class="math notranslate nohighlight">\(L_i\)</span>.</p>
</dd>
<dt><strong>mindex_type</strong><span class="classifier">{‘total_order’, ‘hyperbolic’}, default=’total_order’</span></dt><dd><p>Different types of multiindex generators. Total order produces basis vectors
that have a maximum order as defined by <strong>order</strong>. Hyperbolic order is
similar but generates fewer cross terms.</p>
</dd>
<dt><strong>coef</strong><span class="classifier">numpy.ndarray, default=None</span></dt><dd><p>1d numpy coefficient array if defining polynomial. Must be the same length
as the number of basis elements, i.e. length of multiindex array.</p>
</dd>
<dt><strong>polytype</strong><span class="classifier">{‘Legendre’}, default=’Legendre’</span></dt><dd><p>A string representing the type of polynomial. So far we only include
Legendre polynomial construction defined on [-1,1]</p>
</dd>
<dt><strong>fit_type</strong><span class="classifier">{‘linear’,’LassoCV’,’ElasticNetCV’,’OmpCV’,’quadrature’}, default=’linear’</span></dt><dd><p>A string defining the algorithm to solve the linear regression problem. All but the quadrature option utilizes sklearn’s linear regression algorithms. In order to use the quadrature routine, you must define the ‘w’ variable in the fit_params dictionary.</p>
</dd>
<dt><strong>fit_params</strong><span class="classifier">default={}</span></dt><dd><p>Dictionary to be passed to the particular fit type algorithm chosen above. See sklearn’s documentation for parameters. This dictionary will be passed as a <a href="#id2"><span class="problematic" id="id3">**</span></a>kwargs type input for the fit algorithm.</p>
</dd>
<dt><strong>normalized</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether or not to use normalized polynomials such that
<span class="math notranslate nohighlight">\(\int_{-1}^{1}L_i(x)dx = 1\)</span> or <span class="math notranslate nohighlight">\(\frac{2}{2n+1}\)</span> if True or False, respecively, where
<span class="math notranslate nohighlight">\(n\)</span> is the order of the polynomial (only for Legendre polynomials).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>Dimension of the polynomial, defined after construction.</p>
</dd>
<dt><strong>mindex</strong><span class="classifier">ndarray of shape (nbasis, dim)</span></dt><dd><p>Integer array of the multiindex which describes the structure of the
polynomial basis.</p>
</dd>
<dt><strong>nPCTerms</strong><span class="classifier">int</span></dt><dd><p>The number of basis terms of the multi-variate polynomial.</p>
</dd>
<dt><strong>feature_importances_</strong><span class="classifier">ndarray of shape (dim,)</span></dt><dd><p>Sobol sensitivity indices for each dimension. This is computed after the fit function is called.</p>
</dd>
<dt><strong>coef</strong><span class="classifier">ndarray of shape (nbasis,)</span></dt><dd><p>coefficient array of polynomial function. It can be fed into the constructor, but for most cases it will be computed after self.fit is called.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As of now, the base class requires the input range to be on the default
range <span class="math notranslate nohighlight">\([-1,1]\)</span> for all dimensions. We have included a useful
preprocessing utility (<code class="docutils literal notranslate"><span class="pre">DomainScaler</span></code>) to transform the domain easily to
the canonical target range from any input range. In the future this will be
an option in the this class.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tesuract</span> <span class="kn">import</span> <span class="n">PCEReg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PCEReg</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tesuract.PCEReg.feature_importances" title="tesuract.PCEReg.feature_importances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_importances</span></code></a>()</p></td>
<td><p>Compute feature importances which are equivalent to the normalized Sobol total order sensitivity indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tesuract.PCEReg.fit" title="tesuract.PCEReg.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X, y)</p></td>
<td><p>Fit the polynomial using linear regression or quadrature solvers</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tesuract.PCEReg.joint_effects" title="tesuract.PCEReg.joint_effects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">joint_effects</span></code></a>()</p></td>
<td><p>Compute Sobol joint effect sensitivity indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tesuract.PCEReg.predict" title="tesuract.PCEReg.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(X)</p></td>
<td><p>After fitting, evaluates the polynomial for a single feature space sample or array of samples.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 68%" />
<col style="width: 32%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>computeJointSobol</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tesuract.PCEReg._compile">
<code class="sig-name descname">_compile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEReg._compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the multiindex using the PCEBuilder class. Private.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">numpy array of size (nsamples, dim)</span></dt><dd><p>data matrix in feature space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">self</span></dt><dd><p>returns object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tesuract.PCEReg._quad_fit">
<code class="sig-name descname">_quad_fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEReg._quad_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the coefficients of the polynomial model using quadrature points and weights</p>
<p>It is expected that the data matrix X represent the quadrature point and the weights are given in the fit_params dictionary with the key name ‘w’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">numpy.ndarray of size (nsamples, dim)</span></dt><dd><p>Data matrix where each row is the first part of the data pairs (x,y)_i. X values must be between (-1,1), for now.</p>
</dd>
<dt><strong>y</strong><span class="classifier">numpy.ndarray of size (nsamples,)</span></dt><dd><p>1d array of the data labels. Must be the same size as the number of rows of X.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tesuract.PCEReg.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEReg.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the polynomial using linear regression or quadrature solvers</p>
<p>The algorithm is determined by the fit_type option in the initialization and the options in fit_params.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">numpy.ndarray of shape (nsamples, dim)</span></dt><dd><p>data matrix feature space samples. Must be in [-1,1]</p>
</dd>
<dt><strong>y</strong><span class="classifier">numpy.ndarray of shape (nsamples,)</span></dt><dd><p>data labels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">self object</span></dt><dd><p>sets the internal coefficient array <a href="#id4"><span class="problematic" id="id5">self.coef_</span></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tesuract.PCEReg.feature_importances">
<code class="sig-name descname">feature_importances</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEReg.feature_importances" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute feature importances which are equivalent to the normalized Sobol total order sensitivity indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>feature_importances_</strong><span class="classifier">numpy.ndarray of shape (dim,)</span></dt><dd><p>array representing normalized Sobol total order indices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tesuract.PCEReg.joint_effects">
<code class="sig-name descname">joint_effects</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEReg.joint_effects" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Sobol joint effect sensitivity indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>joint_effects_</strong><span class="classifier">numpy.ndarray of shape (dim,dim)</span></dt><dd><p>the lower triangular part of the array contains the joint effect sensitivity indices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tesuract.PCEReg.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tesuract.PCEReg.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>After fitting, evaluates the polynomial for a single feature space sample or array of samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">numpy.ndarray of shape (nsamples, dim)</span></dt><dd><p>Samples to evaluate the fit polynomial. Must have <a href="#id6"><span class="problematic" id="id7">self.coef_</span></a> set or defined already. Can take 1d or 2d array of samples.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">numpy.ndarray of shape (nsamples,)</span></dt><dd><p>Returns the scalar array of polynomial evaluations.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="tutorials/tutorial02.html" class="btn btn-neutral float-left" title="Some other usage cases" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, K. Chowdhary

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>