
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tesuract.pce &#8212; tesuract 0.2.0 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href="../../_static/style.css" rel="stylesheet" type="text/css">

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/tesuract_logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">tesuract 0.2.0 documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../introduction.html">
   Main features
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../install.html">
   Installation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  User Guide
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../tutorials/Polynomial_fitting.html">
   Fitting with sklearnâ€™s API
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../tutorials/Model_comparison.html">
   Model comparison
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../tutorials/Hyperparameter_tuning.html">
   Hyper-parameter tuning
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../tutorials/Feature_importances.html">
   Feature Importances
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../tutorials/Tensor_surrogates.html">
   Tensor or field surrogates
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  API
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../api.html">
   PCE Base Class
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../api2.html">
   PCE Regression Class
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/kennychowdhary/tesuract"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for tesuract.pce</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pdb</span><span class="o">,</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">pickle</span><span class="o">,</span> <span class="nn">time</span>

<span class="c1"># from tqdm import tqdm</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">RegressorMixin</span><span class="p">,</span> <span class="n">TransformerMixin</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">PolynomialFeatures</span>

<span class="kn">from</span> <span class="nn">.multiindex</span> <span class="kn">import</span> <span class="n">RecursiveHypMultiIndex</span>
<span class="kn">from</span> <span class="nn">.multiindex</span> <span class="kn">import</span> <span class="n">MultiIndex</span>
<span class="kn">from</span> <span class="nn">.preprocessing</span> <span class="kn">import</span> <span class="n">DomainScaler</span>

<span class="kn">from</span> <span class="nn">sklearn.utils.estimator_checks</span> <span class="kn">import</span> <span class="n">check_estimator</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.validation</span> <span class="kn">import</span> <span class="n">check_X_y</span><span class="p">,</span> <span class="n">check_array</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">linear_model</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Acknowledgement:</span>
<span class="sd">The PCE functionality was inspired by my work on UQTk (https://github.com/sandialabs/UQTk). </span>
<span class="sd">All Python code is original. </span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># from numba import jit</span>

<span class="c1"># Polynomials classes</span>
<span class="k">class</span> <span class="nc">PolyBase</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">Eval1dBasis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># virtual fun to compute basis values at x up to order K</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">Eval1dBasisNorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># virtual fun to compute norm basis values at x up to order K</span>
        <span class="k">pass</span>


<span class="k">def</span> <span class="nf">Leg1dPoly</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">5.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">35.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mf">30.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">3.0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">63.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">5</span> <span class="o">-</span> <span class="mf">70.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mf">15.0</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">231.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">6</span> <span class="o">-</span> <span class="mf">31.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mf">105.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">5.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">class</span> <span class="nc">LegPoly2</span><span class="p">(</span><span class="n">PolyBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Usage for 1d polynomial basis construction</span>
<span class="sd">    L = LegPoly()</span>
<span class="sd">    x = np.linspace(-1,1,100)</span>
<span class="sd">    L.plotBasis(x,K,normed=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">Eval1dBasis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
        <span class="c1"># returns matrix where each column is Li(x)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">K</span>
        <span class="c1"># assert jnp.all(x&gt;=self.a) and jnp.all(x&lt;=self.b), &quot;x is not in the domain.&quot;</span>
        <span class="c1"># transform x to [-1,1]</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span>
        <span class="c1"># assert jnp.all(x0&gt;=-1) and jnp.all(x0&lt;=1), &quot;x is not in the domain.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lis</span> <span class="o">=</span> <span class="p">[</span><span class="n">Leg1dPoly</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lis</span><span class="p">)</span>  <span class="c1"># dim x nx</span>

    <span class="k">def</span> <span class="nf">normsq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
        <span class="c1"># compute the squared norm of each basis up to K</span>
        <span class="n">bma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">normsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bma</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normsq</span> <span class="o">=</span> <span class="n">normsq</span>
        <span class="k">return</span> <span class="n">normsq</span>


<span class="kn">from</span> <span class="nn">numpy.polynomial.legendre</span> <span class="kn">import</span> <span class="n">Legendre</span>


<span class="k">class</span> <span class="nc">LegPoly</span><span class="p">(</span><span class="n">PolyBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Usage for 1d polynomial basis construction</span>
<span class="sd">    L = LegPoly()</span>
<span class="sd">    x = np.linspace(-1,1,100)</span>
<span class="sd">    L.plotBasis(x,K,normed=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">Eval1dBasis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
        <span class="c1"># returns matrix where each column is Li(x)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">K</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lis</span> <span class="o">=</span> <span class="p">[</span><span class="n">Legendre</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Li</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">Li</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lis</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">normsq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
        <span class="c1"># compute the squared norm of each basis up to K</span>
        <span class="n">bma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">normsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bma</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normsq</span> <span class="o">=</span> <span class="n">normsq</span>
        <span class="k">return</span> <span class="n">normsq</span>


<span class="k">class</span> <span class="nc">LegPolyNorm</span><span class="p">(</span><span class="n">PolyBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Usage for 1d polynomial basis construction</span>
<span class="sd">    L = LegPoly()</span>
<span class="sd">    x = np.linspace(-1,1,100)</span>
<span class="sd">    L.plotBasis(x,K,normed=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">Eval1dBasis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
        <span class="c1"># returns matrix where each column is Li(x)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">K</span>
        <span class="c1"># compute norms</span>
        <span class="n">normsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lis</span> <span class="o">=</span> <span class="p">[</span><span class="n">Legendre</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Li</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">normsq</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">Li</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lis</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">normsq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
        <span class="c1"># compute the squared norm of each basis up to K</span>
        <span class="n">bma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">normsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bma</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normsq</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">normsq</span>
        <span class="k">return</span> <span class="n">normsq</span>


<span class="k">class</span> <span class="nc">PolyFactory</span><span class="p">:</span>
    <span class="c1"># generates PolyBase class object</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">newPoly</span><span class="p">(</span><span class="n">polytype</span><span class="o">=</span><span class="s2">&quot;Leg&quot;</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">LegPoly</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">L</span>

    <span class="k">def</span> <span class="nf">newPoly</span><span class="p">(</span><span class="n">polytype</span><span class="o">=</span><span class="s2">&quot;LegNorm&quot;</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">LegPolyNorm</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">L</span>


<div class="viewcode-block" id="PCEBuilder"><a class="viewcode-back" href="../../api.html#tesuract.PCEBuilder">[docs]</a><span class="k">class</span> <span class="nc">PCEBuilder</span><span class="p">(</span><span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for building a multivariate polynomial basis.</span>

<span class="sd">    This class creates a multi-variate polynomial object, aka as a polynomial</span>
<span class="sd">    chaos model. The expansion looks like</span>

<span class="sd">    .. math::</span>

<span class="sd">        \sum_{i=1}^N c_i \Phi_i(\mathbf{x})</span>

<span class="sd">    where :math:`N` is the number of polynomial terms, and :math:`\Phi_i:\mathbf{x} \in \mathbb{R}^d \mapsto \mathbb{R}` is the multivariate basis function which takes the form</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Phi_i = \prod_{j=1}^d L_{\\alpha_j^{(i)}}(x_i),</span>

<span class="sd">    where :math:`\\alpha_j` is an integer tuple of size :math:`d` which</span>
<span class="sd">    represents the multiindex, and :math:`L:\mathbb{R} \mapsto \mathbb{R}` are</span>
<span class="sd">    the one-dimensional Legendre polynomials. So for example, in two dimensions,</span>
<span class="sd">    we can have :math:`\Phi_i = xy`. The construction of the multiindex is done</span>
<span class="sd">    behind the scenes in the ``multindex`` module.</span>

<span class="sd">    Below we list the parameters to construct the object followed by the class</span>
<span class="sd">    attributes and returns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    order : int, default=1</span>

<span class="sd">        Description of the order of the polynomials in the expansion. For total order, the order is the maximum polynomial order for each basis function per dimension.</span>

<span class="sd">    customM : numpy.ndarray, default=None</span>

<span class="sd">        An integer numpy aray of size (# of basis functions, # of dimensions). Each</span>
<span class="sd">        row represents the basis function and each column represents the order of</span>
<span class="sd">        the 1d polynomial, :math:`L_i`.</span>

<span class="sd">    mindex_type : {&#39;total_order&#39;, &#39;hyperbolic&#39;}, default=&#39;total_order&#39;</span>

<span class="sd">        Different types of multiindex generators. Total order produces basis vectors</span>
<span class="sd">        that have a maximum order as defined by **order**. Hyperbolic order is</span>
<span class="sd">        similar but generates fewer cross terms.</span>

<span class="sd">    coef : numpy.ndarray, default=None</span>

<span class="sd">        1d numpy coefficient array if defining polynomial. Must be the same length</span>
<span class="sd">        as the number of basis elements, i.e. length of multiindex array.</span>

<span class="sd">    polytype : {&#39;Legendre&#39;}, default=&#39;Legendre&#39;</span>

<span class="sd">        A string representing the type of polynomial. So far we only include</span>
<span class="sd">        Legendre polynomial construction defined on [-1,1]</span>

<span class="sd">    normalized : bool, default=False</span>

<span class="sd">        Whether or not to use normalized polynomials such that</span>
<span class="sd">        :math:`\int_{-1}^{1}L_i(x)dx = 1` or :math:`\\frac{2}{2n+1}` if True or False, respecively, where</span>
<span class="sd">        :math:`n` is the order of the polynomial (only for Legendre polynomials).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : int</span>

<span class="sd">        Dimension of the polynomial, defined after construction.</span>

<span class="sd">    mindex : ndarray of shape (nbasis, dim)</span>

<span class="sd">        Integer array of the multiindex which describes the structure of the</span>
<span class="sd">        polynomial basis.</span>

<span class="sd">    nPCTerms : int</span>

<span class="sd">        The number of basis terms of the multi-variate polynomial.</span>

<span class="sd">    coef    : ndarray of shape (nbasis,)</span>

<span class="sd">        Coefficient array</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    compile:</span>
<span class="sd">        pre-processing for fit, e.g., multiindex generation</span>
<span class="sd">    computeMoments:</span>
<span class="sd">        compute means and variances using PCE coefficients</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    As of now, the base class requires the input range to be on the default</span>
<span class="sd">    range :math:`[-1,1]` for all dimensions. We have included a useful</span>
<span class="sd">    preprocessing utility (``DomainScaler``) to transform the domain easily to</span>
<span class="sd">    the canonical target range from any input range. In the future this will be</span>
<span class="sd">    an option in the this class.</span>

<span class="sd">    Todo</span>
<span class="sd">    -----</span>
<span class="sd">    * Add option for non-standard domain.</span>
<span class="sd">    * Add attribute for feature_importances() is polynomial is defined.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from tesuract import PCEBuilder</span>
<span class="sd">    &gt;&gt;&gt; p = PCEBuilder(order=3,normalized=True)</span>
<span class="sd">    &gt;&gt;&gt; print(p.mindex)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">customM</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mindex_type</span><span class="o">=</span><span class="s2">&quot;total_order&quot;</span><span class="p">,</span>
        <span class="n">coef</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">polytype</span><span class="o">=</span><span class="s2">&quot;Legendre&quot;</span><span class="p">,</span>
        <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">store_phi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">input_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_sklearn_poly_features</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># self.dim = dim # no need to initialize with dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">customM</span> <span class="o">=</span> <span class="n">customM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mindex_type</span> <span class="o">=</span> <span class="n">mindex_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coef</span> <span class="o">=</span> <span class="n">coef</span>
        <span class="c1"># self.coef_ = self.coef</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polytype</span> <span class="o">=</span> <span class="n">polytype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>  <span class="c1"># lower bounds on domain of x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>  <span class="c1"># upper bound on domain of x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compile_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_range</span> <span class="o">=</span> <span class="n">input_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span> <span class="o">=</span> <span class="n">normalized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mindex_compute_count_</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_phi</span> <span class="o">=</span> <span class="n">store_phi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_sklearn_poly_features</span> <span class="o">=</span> <span class="n">use_sklearn_poly_features</span>

<div class="viewcode-block" id="PCEBuilder.compile"><a class="viewcode-back" href="../../api.html#tesuract.PCEBuilder.compile">[docs]</a>    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setup for instantiating the basis class</span>

<span class="sd">        Constructs the multi-dimensional multi-index which defines the</span>
<span class="sd">        polynomial basis elements. Note that this is only done once during the</span>
<span class="sd">        fit method of the class, unless the mindex variable is undefined.</span>

<span class="sd">        The multi-index array is of size :math:`N \\times dim` where :math:`N`</span>
<span class="sd">        is the number of basis elements. The multi-index determine the order or</span>
<span class="sd">        degree of the univariate polynomial in</span>

<span class="sd">        .. math::</span>

<span class="sd">            \Phi_i = \prod_{j=1}^d L_{\\alpha_j^{(i)}}(x_i).</span>

<span class="sd">        So for example, :math:`\\alpha_j=2` corresponds to a second order or</span>
<span class="sd">        quadratic Legendre polynomial.</span>

<span class="sd">        Lastly, this method also defines the number of basis elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        dim : int</span>

<span class="sd">            dimension of the polynomials</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        self: object</span>

<span class="sd">            Returns the object itself.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="c1"># constructor for different multindices (None, object, and array)</span>
        <span class="c1">##############################################################</span>
        <span class="c1"># Note that sklearn base cv search clones each estimator so that the multi-index is created for each cv sub score</span>
        <span class="c1"># Here we recompute the multiindex only if mindex is None or if the X dimension does not match the already existing mindex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">customM</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># only place where the multindex is computed!</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># compute when mindex is None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex_type</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mindex_compute_count_</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># print(self.M.index.shape)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="c1"># don&#39;t recompute if dimension stays the same</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># recompute when dim changes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex_type</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mindex_compute_count_</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1">##############################################################</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">customM</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="c1"># print(&quot;Using custom Multiindex object.&quot;)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">customM</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="n">dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">customM</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">customM</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">customM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># set dim to match multiindex</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mindex_type</span><span class="o">=</span><span class="s2">&quot;total_order&quot;</span>
            <span class="p">)</span>  <span class="c1"># setup default</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">setIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">customM</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># leave blank to indicate custom order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Converting multindex array to integer array.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nPCTerms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># if self.coef is not None:</span>
        <span class="c1">#     assert len(self.coef) == self.mindex.shape[0], &quot;coefficient array is not the same size as the multindex array.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compile_flag</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">_fit_transform_sklearn_poly_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile the polynomial feature matrix using the sklearn.PolynomialFeatures class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;polyT&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyT</span> <span class="o">=</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">include_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyT</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">computeNormSq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Separate method to compute norms, in order to bypass construct basis. For use when computing the feature importance/ Sobol sensitivity indices.&quot;&quot;&quot;</span>
        <span class="n">mindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span>  <span class="c1"># use internal mindex array</span>
        <span class="c1"># L = []</span>
        <span class="n">Kmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">NormSq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="c1"># Compute Legendre objects and eval 1d basis</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">Leg</span> <span class="o">=</span> <span class="n">LegPoly</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">Leg</span> <span class="o">=</span> <span class="n">LegPolyNorm</span><span class="p">()</span>
            <span class="n">NormSq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Leg</span><span class="o">.</span><span class="n">normsq</span><span class="p">(</span><span class="n">Kmax</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>  <span class="c1"># norms up to K order</span>

        <span class="c1"># start computing products</span>
        <span class="c1"># Phi = 1.0</span>
        <span class="n">normsq</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="c1"># Phi = L[di][self.mindex[:,di]] * Phi</span>
            <span class="n">normsq</span> <span class="o">=</span> <span class="n">NormSq</span><span class="p">[</span><span class="n">di</span><span class="p">][</span><span class="n">mindex</span><span class="p">[:,</span> <span class="n">di</span><span class="p">]]</span> <span class="o">*</span> <span class="n">normsq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normsq</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">normsq</span>  <span class="c1"># norm squared * integration factor of 1/2 (since domain is [-1,1])</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">normsq</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">normsq</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="c1"># cannot name it self.fit() otherwise PCEReg would overwrite it</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># only compiles once</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="PCEBuilder.transform"><a class="viewcode-back" href="../../api.html#tesuract.PCEBuilder.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform the given :math:`X` coordinates to the polynomial</span>
<span class="sd">        space.</span>

<span class="sd">        This method essentially performs a high dimensional kernel mapping onto</span>
<span class="sd">        a polynomial space spanned by the Legendre polynomials. This is similar</span>
<span class="sd">        to sklearn&#39;s PolynomialFeatures, except here the features are</span>
<span class="sd">        multi-variate Legendre; the big difference being that the features are</span>
<span class="sd">        uncorrelated.</span>

<span class="sd">        Alternatively, the resulting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        X   :  numpy.ndarray of shape (nsamples, dim)</span>

<span class="sd">            feature matrix where each row is a sample of the feature space.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Phi :  numpy.ndarray of shape (nsamples, nPCTerms)</span>

<span class="sd">            returns the polynomial feature map that transforms each sample in :math:`X` of dimension :math:`d` to dimension :math:`nPCTerms`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Scale X if input range to (-1,1) if range is specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scaler</span> <span class="o">=</span> <span class="n">DomainScaler</span><span class="p">(</span>
                <span class="n">dim</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">input_range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_range</span><span class="p">,</span> <span class="n">output_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X_scaled</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># only works for [-1,1] for far</span>
        <span class="c1"># compute multindex</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="p">),</span> <span class="s2">&quot;range for X must be between -1 and 1 for now. scale inputs accordingly. &quot;</span>

        <span class="c1"># if sklearn poly selected then use sklearn</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sklearn_poly_features</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>

            <span class="n">Max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># construct and evaluate each basis using mindex</span>
            <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">NormSq</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_type</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_type</span> <span class="o">=</span> <span class="s2">&quot;scalar&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                <span class="c1"># Compute Legendre objects and eval 1d basis</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">Leg</span> <span class="o">=</span> <span class="n">LegPoly</span><span class="p">()</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">Leg</span> <span class="o">=</span> <span class="n">LegPolyNorm</span><span class="p">()</span>
                <span class="n">Li_max</span> <span class="o">=</span> <span class="n">Leg</span><span class="o">.</span><span class="n">Eval1dBasis</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">K</span><span class="o">=</span><span class="n">Max</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Li_max</span><span class="p">)</span>  <span class="c1"># list of size dim of Legendre polys</span>
                <span class="n">NormSq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Leg</span><span class="o">.</span><span class="n">normsq</span><span class="p">(</span><span class="n">Max</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>  <span class="c1"># norms up to K order</span>

            <span class="c1"># start computing products</span>
            <span class="n">Phi</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">normsq</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">L_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

            <span class="c1"># # method 2 looping over number of samples</span>
            <span class="c1"># start = time.time()</span>
            <span class="c1"># I = self.mindex.T</span>
            <span class="c1"># I0 = np.ones_like(I)*np.arange(self.dim)[:,np.newaxis]</span>
            <span class="c1"># Lbig = L_array[I0.ravel(),I.ravel(),:]</span>
            <span class="c1"># # Phi = np.prod(Lbig,axis=0)</span>
            <span class="c1"># # self.Phi = Phi.T</span>
            <span class="c1"># print(time.time() - start)</span>

            <span class="c1"># method 2 - looping over dimensions</span>
            <span class="c1"># start = time.time()</span>
            <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                <span class="c1"># if di%2 == 0: print(&quot;main prod loop...&quot;, di)</span>
                <span class="n">Phi</span> <span class="o">=</span> <span class="n">L_array</span><span class="p">[</span><span class="n">di</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="p">[:,</span> <span class="n">di</span><span class="p">]]</span> <span class="o">*</span> <span class="n">Phi</span>
                <span class="n">normsq</span> <span class="o">=</span> <span class="n">NormSq</span><span class="p">[</span><span class="n">di</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="p">[:,</span> <span class="n">di</span><span class="p">]]</span> <span class="o">*</span> <span class="n">normsq</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_phi</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Phi</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normsq</span> <span class="o">=</span> <span class="n">normsq</span>  <span class="c1"># norm squared</span>
            <span class="c1"># print(time.time() - start)</span>

            <span class="c1"># if self.normalized:</span>
            <span class="c1">#     return self.Phi/np.sqrt(normsq)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     return self.Phi</span>
            <span class="c1"># pdb.set_trace()</span>
            <span class="k">return</span> <span class="n">Phi</span><span class="o">.</span><span class="n">T</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sklearn_poly_features</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">Vander</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_transform_sklearn_poly_features</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Vander</span></div>

<div class="viewcode-block" id="PCEBuilder.fit_transform"><a class="viewcode-back" href="../../api.html#tesuract.PCEBuilder.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit and transform the given :math:`X` coordinates to the polynomial</span>
<span class="sd">        space.</span>

<span class="sd">        This method essentially performs a high dimensional kernel mapping onto</span>
<span class="sd">        a polynomial space spanned by the Legendre polynomials. This is similar</span>
<span class="sd">        to sklearn&#39;s PolynomialFeatures, except here the features are</span>
<span class="sd">        multi-variate Legendre; the big difference being that the features are</span>
<span class="sd">        uncorrelated.</span>

<span class="sd">        Alternatively, the resulting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        X   :  numpy.ndarray of shape (nsamples, dim)</span>

<span class="sd">            feature matrix where each row is a sample of the feature space.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Phi :  numpy.ndarray of shape (nsamples, nPCTerms)</span>

<span class="sd">            returns the polynomial feature map that transforms each sample in :math:`X` of dimension :math:`d` to dimension :math:`nPCTerms`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="PCEBuilder.polyeval"><a class="viewcode-back" href="../../api.html#tesuract.PCEBuilder.polyeval">[docs]</a>    <span class="k">def</span> <span class="nf">polyeval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to evaluate the polynomial.</span>

<span class="sd">        Evaluates the polynomial for a given set of coefficients and data</span>
<span class="sd">        points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        X   :  numpy.ndarray of shape (nsamples, dim)</span>

<span class="sd">            feature matrix where each row is a sample of the feature space.</span>

<span class="sd">        c   : numpy.ndarray of shape (nPCTerms,) (optional)</span>

<span class="sd">            coefficient array. The evaluation is simply np.dot(Phi,c). The coefficient array can also be internally set so that it does not need to be fed in each time we need to evaluate the polynomial.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        yeval   : numpy.ndarray of shape (X.shape[0],)</span>

<span class="sd">            The scalar outputs of the multivariate polynomial evaluated at the feature matrix data points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coef_</span> <span class="o">=</span> <span class="n">c</span>  <span class="c1"># use c in polyeval</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">compile_flag</span> <span class="o">==</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;Must compile to get multindex.&quot;</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coef_</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;c is not the right size.&quot;</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;Must define coefficient in constructor or polyeval or run the fit method&quot;</span>
            <span class="n">coef_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coef</span>  <span class="c1"># use coefficient from constructor</span>

        <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">yeval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Phi</span><span class="p">,</span> <span class="n">coef_</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">X</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Phi</span>  <span class="c1"># using stored Vandermonde matrix</span>
            <span class="n">yeval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Phi</span><span class="p">,</span> <span class="n">coef_</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">yeval</span></div>

<div class="viewcode-block" id="PCEBuilder.eval"><a class="viewcode-back" href="../../api.html#tesuract.PCEBuilder.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Duplicate of polyeval&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyeval</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span></div>

<div class="viewcode-block" id="PCEBuilder.computeSobol"><a class="viewcode-back" href="../../api.html#tesuract.PCEBuilder.computeSobol">[docs]</a>    <span class="k">def</span> <span class="nf">computeSobol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute Sobol total order variance based sensitivity indices</span>

<span class="sd">        Depending on the Legendre polynomial type (normalized vs non-normalized)</span>
<span class="sd">        the formula will be different. The total order sensitivity is given by</span>

<span class="sd">        .. math::</span>

<span class="sd">            S_i = \sum_{k} \gamma^{-2}_{\\beta^i_k} c^2_{\\beta^i_k}</span>

<span class="sd">        where :math:`\{\\beta^i_k\}_{k=\dots}` are the indices that contain at</span>
<span class="sd">        least the :math:`i^{th}` dimension, and :math:`\gamma` is the square root norm of that particular basis polynomial (which is 1 for the normalized case).</span>

<span class="sd">        For this method, we return the normalized Sobol indices, i.e.</span>

<span class="sd">        .. math::</span>

<span class="sd">            T_i \doteq S_i/S_{T}</span>

<span class="sd">        where :math:`S_{T}` is the total variance, i.e. :math:`\{\\beta^i_k\}_{k=\dots}` are the entire set of basis functions. Thus, the total order sensitivity indices are always less than 1, although their sum can be greater than :math:`S_{T}`.</span>

<span class="sd">        This is another advantage of using the Legendre polynomials, in that they are uncorrelated so that their feature importance calculations are very easy to compute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        c   : numpy.ndarray of shape (nPCTerms,)</span>

<span class="sd">            coefficient to determine the Sobol indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        T   : numpy.ndarray of shape (dim,)</span>

<span class="sd">            The total order Sobol sensitivity indices for each dimension</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="c1"># assert self.compile_flag == True, &quot;Must compile to set mindex. Avoids having to recompute multiindex everytime we run SA.&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normsq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">normsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computeNormSq</span><span class="p">()</span>  <span class="c1"># if c and M specified in constructor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">normsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normsq</span>  <span class="c1"># from fit transform</span>
        <span class="c1"># compute Sobol indices using coefficient vector</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coef</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="p">),</span> <span class="s2">&quot;must specify coefficient array or feed it in the constructor.&quot;</span>
            <span class="n">coef_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coef</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coef_</span> <span class="o">=</span> <span class="n">c</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">coef_</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;Coefficient vector must match the no of rows of the multiindex.&quot;</span>

        <span class="n">new_index</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">)</span>  <span class="c1"># boolean array that doesn&#39;t include mean mindex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">:</span>
            <span class="n">totvar_vec</span> <span class="o">=</span> <span class="n">coef_</span><span class="p">[</span><span class="n">new_index</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coefsq</span> <span class="o">=</span> <span class="n">coef_</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">totvar_vec</span> <span class="o">=</span> <span class="n">normsq</span><span class="p">[</span><span class="n">new_index</span><span class="p">]</span> <span class="o">*</span> <span class="n">coef_</span><span class="p">[</span><span class="n">new_index</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coefsq</span> <span class="o">=</span> <span class="n">normsq</span> <span class="o">*</span> <span class="n">coef_</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">totvar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">totvar_vec</span><span class="p">)</span>
        <span class="c1"># assert totvar &gt; 0, &quot;Coefficients are all zero!&quot;</span>
        <span class="n">S</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># in case elements have nan in them</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">coef_</span><span class="p">[</span><span class="n">new_index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1"># ignore the mean</span>
            <span class="c1"># print(&quot;Returning equal weights!&quot;)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>  <span class="c1"># return equal weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sobol_variances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">si</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="c1"># boolean</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">totvar_vec</span><span class="p">[</span><span class="n">si</span><span class="p">[</span><span class="n">new_index</span><span class="p">]])</span> <span class="o">/</span> <span class="n">totvar</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sobol_variances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">totvar</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span>  <span class="c1"># just the variance</span>
                <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="c1"># note that s does not have to sum to 1</span>
        <span class="k">return</span> <span class="n">S</span></div>

    <span class="k">def</span> <span class="nf">computeJointSobol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="c1"># assert self.compile_flag == True, &quot;Must compile to set mindex. Avoids having to recompute multiindex everytime we run SA.&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normsq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">normsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computeNormSq</span><span class="p">()</span>  <span class="c1"># if c and M specified in constructor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">normsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normsq</span>  <span class="c1"># from fit transform</span>
        <span class="c1"># compute Sobol indices using coefficient vector</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coef</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="p">),</span> <span class="s2">&quot;must specify coefficient array or feed it in the constructor.&quot;</span>
            <span class="n">coef_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coef</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coef_</span> <span class="o">=</span> <span class="n">c</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">coef_</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;Coefficient vector must match the no of rows of the multiindex.&quot;</span>

        <span class="c1"># new_index = (np.sum(self.mindex,1)!=0) # boolean array that doesn&#39;t include mean mindex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">:</span>
            <span class="n">totvar_vec</span> <span class="o">=</span> <span class="n">coef_</span><span class="o">**</span><span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coefsq</span> <span class="o">=</span> <span class="n">coef_</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">totvar_vec</span> <span class="o">=</span> <span class="n">normsq</span> <span class="o">*</span> <span class="n">coef_</span><span class="o">**</span><span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coefsq</span> <span class="o">=</span> <span class="n">normsq</span> <span class="o">*</span> <span class="n">coef_</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">totvar_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">totvar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">totvar_vec</span><span class="p">)</span>

        <span class="c1"># fill in joint sensitivities</span>
        <span class="n">S2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>  <span class="c1"># joint sobol matrix</span>
        <span class="n">dim_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>  <span class="c1"># list of dimensions</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">dim_list</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># all unique pairs of dimensions</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="c1"># For each pair of dimensions, compute the total variance of the iteraction terms</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">s2i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="c1"># index where first dim in pair &gt; 0</span>
            <span class="n">s2j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="c1"># index where first dim in pair &gt; 0</span>
            <span class="n">pindex_temp</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">s2i</span><span class="p">,</span> <span class="n">s2j</span><span class="p">)</span>
            <span class="p">]</span>  <span class="c1"># index where both dimensions in pair as nonzero</span>
            <span class="n">js</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">totvar_vec</span><span class="p">[</span><span class="n">pindex_temp</span><span class="p">])</span> <span class="o">/</span> <span class="n">totvar</span>
            <span class="p">)</span>  <span class="c1"># compute tot var if elements in pair</span>
            <span class="n">S2</span><span class="p">[</span>
                <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">js</span>  <span class="c1"># fill in joint sensitivity matrix which will be upper diagonal, with zero for diagonal entries</span>
        <span class="k">return</span> <span class="n">S2</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># return transpose of upper diagonal to get lower diagonal matrix</span>

<div class="viewcode-block" id="PCEBuilder.computeMoments"><a class="viewcode-back" href="../../api.html#tesuract.PCEBuilder.computeMoments">[docs]</a>    <span class="k">def</span> <span class="nf">computeMoments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Methods to compute the mean and variance of the resulting polynomial</span>

<span class="sd">        Assuming a uniform distribution over :math:`[-1,1]`, this method</span>
<span class="sd">        computes the mean and variance. The mean is the coefficient of the</span>
<span class="sd">        :math:`0^{th}` order term, while the variance is the weighted sum of</span>
<span class="sd">        squares of the other coefficients. The weighted sum is determined by</span>
<span class="sd">        using either the normalized or non-normalized Legendre polynomials.</span>
<span class="sd">        Finally, the weight is scaled by .5 correpsonding to the density</span>
<span class="sd">        function for the uniform distribution on the previously stated domain.</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mu = \\frac{1}{2} c_0</span>

<span class="sd">        .. math::</span>

<span class="sd">            \sigma^2 = \\frac{1}{2} \sum_{i=1}^N \gamma^2_i c^2_i</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        c   : numpy.ndarray of shape (nPCTerms, )</span>

<span class="sd">            coefficient of the polynomial basis. Must have the same number of elements as the number of basis elements.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        mu, var : float,float</span>

<span class="sd">            mean and variance floating point values</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;coef is not defined. Try running fit or input c&quot;</span>
            <span class="n">coef_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coef</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coef_</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mindex</span><span class="p">),</span> <span class="s2">&quot;coef is wrong size&quot;</span>
        <span class="c1"># normsq = self.computeNormSq()</span>
        <span class="n">normsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normsq</span>
        <span class="n">prob_weight</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">prob_weight</span> <span class="o">*</span> <span class="n">normsq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">coef_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">prob_weight</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">normsq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">coef_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">prob_weight</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">normsq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">coef_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">prob_weight</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coef_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var</span></div></div>


<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">simplefilter</span>
<span class="kn">from</span> <span class="nn">sklearn.exceptions</span> <span class="kn">import</span> <span class="n">ConvergenceWarning</span>

<span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">ConvergenceWarning</span><span class="p">)</span>

<span class="c1"># regressor mixin is to add scoring, and baseestimator is to add fit, predict</span>
<div class="viewcode-block" id="PCEReg"><a class="viewcode-back" href="../../api2.html#tesuract.PCEReg">[docs]</a><span class="k">class</span> <span class="nc">PCEReg</span><span class="p">(</span><span class="n">PCEBuilder</span><span class="p">,</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">RegressorMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for performing multivariate polynomial regression</span>

<span class="sd">    This class fits the coefficients of a a multivariate polynomial object, aka</span>
<span class="sd">    as a polynomial chaos model, using different linear regression algorithms</span>
<span class="sd">    from sklearn. Given labeled data pairs :math:`(x_j,y_j)` for</span>
<span class="sd">    :math:`j=1,\dots,n`, where :math:`x_j \in \mathbb{R}^d` and :math:`y_j \in \mathbb{R}`, we look for</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\text{arg} \min_{c} \sum_{j}d\left(f(\mathbf{x}_j;c),y_j\\right) + \\text{Regularizer}(c)</span>

<span class="sd">    where :math:`f` is the polynomial model with unknown coefficient parameters, i.e.,</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(\mathbf{x}_j;c) \doteq \sum_{i=1}^N c_i \Phi_i(\mathbf{x}_j)</span>

<span class="sd">    where :math:`d` is the error metric, which is typically a squared error, and the regularizer can be either :math:`\ell_1` (lasso), :math:`\ell_2` (ridge), or both (elastic net). Again, we note that the input must be on :math:`[-1,1]` for now since the polynomials are setup on that domain by default. One may use sklearn&#39;s preprocessing utilities to make that transformation or use the DomainScaler class that comes with this library.</span>

<span class="sd">    Below we list the parameters to construct the object followed by the class</span>
<span class="sd">    attributes and returns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    order : int, default=2</span>

<span class="sd">        Description of the order of the polynomials in the</span>
<span class="sd">        expansion. For total order, the order is the maximum polynomial order</span>
<span class="sd">        for each basis function per dimension.</span>

<span class="sd">    customM : numpy.ndarray, default=None</span>

<span class="sd">        An integer numpy aray of size (# of basis functions, # of dimensions). Each</span>
<span class="sd">        row represents the basis function and each column represents the order of</span>
<span class="sd">        the 1d polynomial, :math:`L_i`.</span>

<span class="sd">    mindex_type : {&#39;total_order&#39;, &#39;hyperbolic&#39;}, default=&#39;total_order&#39;</span>

<span class="sd">        Different types of multiindex generators. Total order produces basis vectors</span>
<span class="sd">        that have a maximum order as defined by **order**. Hyperbolic order is</span>
<span class="sd">        similar but generates fewer cross terms.</span>

<span class="sd">    coef : numpy.ndarray, default=None</span>

<span class="sd">        1d numpy coefficient array if defining polynomial. Must be the same length</span>
<span class="sd">        as the number of basis elements, i.e. length of multiindex array.</span>

<span class="sd">    polytype : {&#39;Legendre&#39;}, default=&#39;Legendre&#39;</span>

<span class="sd">        A string representing the type of polynomial. So far we only include</span>
<span class="sd">        Legendre polynomial construction defined on [-1,1]</span>

<span class="sd">    fit_type : {&#39;linear&#39;,&#39;LassoCV&#39;,&#39;ElasticNetCV&#39;,&#39;OmpCV&#39;,&#39;quadrature&#39;}, default=&#39;linear&#39;</span>

<span class="sd">        A string defining the algorithm to solve the linear regression problem. All but the quadrature option utilizes sklearn&#39;s linear regression algorithms. In order to use the quadrature routine, you must define the &#39;w&#39; variable in the fit_params dictionary.</span>

<span class="sd">    fit_params : default={}</span>

<span class="sd">        Dictionary to be passed to the particular fit type algorithm chosen above. See sklearn&#39;s documentation for parameters. This dictionary will be passed as a **kwargs type input for the fit algorithm.</span>


<span class="sd">    normalized : bool, default=False</span>

<span class="sd">        Whether or not to use normalized polynomials such that</span>
<span class="sd">        :math:`\int_{-1}^{1}L_i(x)dx = 1` or :math:`\\frac{2}{2n+1}` if True or False, respecively, where</span>
<span class="sd">        :math:`n` is the order of the polynomial (only for Legendre polynomials).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : int</span>

<span class="sd">        Dimension of the polynomial, defined after construction.</span>

<span class="sd">    mindex : ndarray of shape (nbasis, dim)</span>

<span class="sd">        Integer array of the multiindex which describes the structure of the</span>
<span class="sd">        polynomial basis.</span>

<span class="sd">    nPCTerms : int</span>

<span class="sd">        The number of basis terms of the multi-variate polynomial.</span>

<span class="sd">    feature_importances_ : ndarray of shape (dim,)</span>

<span class="sd">        Sobol sensitivity indices for each dimension. This is computed after the fit function is called.</span>

<span class="sd">    coef    : ndarray of shape (nbasis,)</span>

<span class="sd">        coefficient array of polynomial function. It can be fed into the constructor, but for most cases it will be computed after self.fit is called.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    feature_importances:</span>
<span class="sd">        compute Sobol total order indices, normalized to sum to 1</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    As of now, the base class requires the input range to be on the default</span>
<span class="sd">    range :math:`[-1,1]` for all dimensions. We have included a useful</span>
<span class="sd">    preprocessing utility (``DomainScaler``) to transform the domain easily to</span>
<span class="sd">    the canonical target range from any input range. In the future this will be</span>
<span class="sd">    an option in the this class.</span>

<span class="sd">    Todo</span>
<span class="sd">    -----</span>
<span class="sd">    * Add option for non-standard domain.</span>
<span class="sd">    * Add attribute for feature_importances() is polynomial is defined.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from tesuract import PCEReg</span>
<span class="sd">    &gt;&gt;&gt; p = PCEReg(order=3)</span>
<span class="sd">    &gt;&gt;&gt; p.fit(X,y)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">customM</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mindex_type</span><span class="o">=</span><span class="s2">&quot;total_order&quot;</span><span class="p">,</span>
        <span class="n">coef</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">polytype</span><span class="o">=</span><span class="s2">&quot;Legendre&quot;</span><span class="p">,</span>
        <span class="n">fit_type</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">fit_params</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">store_phi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">input_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_sklearn_poly_features</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># alphas=np.logspace(-12,1,20),l1_ratio=[.001,.5,.75,.95,.999,1],lasso_tol=1e-2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mindex_type</span> <span class="o">=</span> <span class="n">mindex_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">customM</span> <span class="o">=</span> <span class="n">customM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coef</span> <span class="o">=</span> <span class="n">coef</span>
        <span class="c1"># self.c = self.coef # need to remove eventually</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polytype</span> <span class="o">=</span> <span class="n">polytype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_type</span> <span class="o">=</span> <span class="n">fit_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="n">fit_params</span>
        <span class="c1"># self.alphas = alphas # LassoCV default</span>
        <span class="c1"># self.l1_ratio = l1_ratio # ElasticNet default</span>
        <span class="c1"># self.lasso_tol = lasso_tol</span>
        <span class="c1"># self.w = w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_phi</span> <span class="o">=</span> <span class="n">store_phi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_range</span> <span class="o">=</span> <span class="n">input_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span> <span class="o">=</span> <span class="n">normalized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_sklearn_poly_features</span> <span class="o">=</span> <span class="n">use_sklearn_poly_features</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span>
            <span class="n">customM</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">customM</span><span class="p">,</span>
            <span class="n">mindex_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mindex_type</span><span class="p">,</span>
            <span class="n">coef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coef</span><span class="p">,</span>
            <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
            <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
            <span class="n">polytype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polytype</span><span class="p">,</span>
            <span class="n">normalized</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">,</span>
            <span class="n">store_phi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">store_phi</span><span class="p">,</span>
            <span class="n">input_range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_range</span><span class="p">,</span>
            <span class="n">use_sklearn_poly_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_sklearn_poly_features</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="PCEReg._compile"><a class="viewcode-back" href="../../api2.html#tesuract.PCEReg._compile">[docs]</a>    <span class="k">def</span> <span class="nf">_compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds the multiindex using the PCEBuilder class. Private.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        X   : numpy array of size (nsamples, dim)</span>

<span class="sd">            data matrix in feature space.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        self    : self</span>

<span class="sd">            returns object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim</span><span class="p">)</span>  <span class="c1"># use parent compile to produce the multiindex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiindex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xhat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="PCEReg._quad_fit"><a class="viewcode-back" href="../../api2.html#tesuract.PCEReg._quad_fit">[docs]</a>    <span class="k">def</span> <span class="nf">_quad_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the coefficients of the polynomial model using quadrature points and weights</span>

<span class="sd">        It is expected that the data matrix X represent the quadrature point and the weights are given in the fit_params dictionary with the key name &#39;w&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X       : numpy.ndarray of size (nsamples, dim)</span>

<span class="sd">                Data matrix where each row is the first part of the data pairs (x,y)_i. X values must be between (-1,1), for now.</span>

<span class="sd">        y       : numpy.ndarray of size (nsamples,)</span>

<span class="sd">                1d array of the data labels. Must be the same size as the number of rows of X.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># let us assume the weights are for [-1,1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compile</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  <span class="c1"># compute normalized or non-normalized Xhat</span>
        <span class="n">normsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computeNormSq</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="s2">&quot;w&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">),</span> <span class="s2">&quot;quadrature weights must be given in dictionary fit_params.&quot;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="s2">&quot;w&quot;</span><span class="p">]</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">check_X_y</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>  <span class="c1"># make sure # quadrature points matces X</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-15</span>
        <span class="p">),</span> <span class="s2">&quot;quadrature weights must be scaled to integrate over [-1,1] with unit weight&quot;</span>
        <span class="n">int_fact</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coef</span> <span class="o">=</span> <span class="n">int_fact</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xhat</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">normsq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coef</span> <span class="o">=</span> <span class="n">int_fact</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xhat</span><span class="p">)</span> <span class="o">/</span> <span class="n">normsq</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="PCEReg.fit"><a class="viewcode-back" href="../../api2.html#tesuract.PCEReg.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the polynomial using linear regression or quadrature solvers</span>

<span class="sd">        The algorithm is determined by the fit_type option in the initialization and the options in fit_params.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        X       : numpy.ndarray of shape (nsamples, dim)</span>

<span class="sd">                data matrix feature space samples. Must be in [-1,1]</span>

<span class="sd">        y       : numpy.ndarray of shape (nsamples,)</span>

<span class="sd">                data labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        self    : self object</span>

<span class="sd">                sets the internal coefficient array self.coef\_</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">check_X_y</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="c1"># get data attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># Check if dimension has changed and clear multiindices and coefficient if that&#39;s the case. If not, leave everythign the same.</span>
        <span class="c1"># fit overwrites the coefficient array if there is a mismatch like if the X dimension changes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coef</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiindex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;coefficient array mismatch. &quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coef</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># set to none and fit again</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_compile</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  <span class="c1"># build multindex and construct basis</span>
        <span class="n">Xhat</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">check_X_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xhat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="c1"># assert len(self.coef) == self.multiindex.shape[0],&quot;length of coefficient vector is not the same shape as the multindex!&quot;</span>
        <span class="c1"># run quadrature fit if weights are specified:</span>
        <span class="n">sample_weights</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>
        <span class="n">sample_weights</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_type</span> <span class="o">==</span> <span class="s2">&quot;quadrature&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_quad_fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_type</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="n">regmodel</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LinearRegression</span><span class="p">(</span><span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">regmodel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xhat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_type</span> <span class="o">==</span> <span class="s2">&quot;LassoCV&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">:</span>  <span class="c1"># if empty dictionary</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;alphas&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span>
                    <span class="s2">&quot;max_iter&quot;</span><span class="p">:</span> <span class="mi">2500</span><span class="p">,</span>
                    <span class="s2">&quot;tol&quot;</span><span class="p">:</span> <span class="mf">1e-2</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="n">regmodel</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LassoCV</span><span class="p">(</span><span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">)</span>
            <span class="n">regmodel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xhat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha_</span> <span class="o">=</span> <span class="n">regmodel</span><span class="o">.</span><span class="n">alpha_</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_type</span> <span class="o">==</span> <span class="s2">&quot;LassoCV_weighted&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">:</span>  <span class="c1"># if empty dictionary</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;alphas&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span>
                    <span class="s2">&quot;max_iter&quot;</span><span class="p">:</span> <span class="mi">2500</span><span class="p">,</span>
                    <span class="s2">&quot;tol&quot;</span><span class="p">:</span> <span class="mf">1e-2</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="c1"># self.fit_params={}</span>
            <span class="n">regmodel</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LassoCV</span><span class="p">(</span><span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">)</span>
            <span class="n">regmodel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xhat</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weights</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha_</span> <span class="o">=</span> <span class="n">regmodel</span><span class="o">.</span><span class="n">alpha_</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_type</span> <span class="o">==</span> <span class="s2">&quot;ElasticNetCV&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">:</span>  <span class="c1"># if empty dictionary</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;l1_ratio&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="s2">&quot;n_alphas&quot;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span>
                    <span class="s2">&quot;tol&quot;</span><span class="p">:</span> <span class="mf">1e-2</span><span class="p">,</span>
                    <span class="s2">&quot;n_jobs&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="n">regmodel</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">ElasticNetCV</span><span class="p">(</span><span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">)</span>
            <span class="n">regmodel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xhat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_type</span> <span class="o">==</span> <span class="s2">&quot;ElasticNetCV_weighted&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">:</span>  <span class="c1"># if empty dictionary</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;l1_ratio&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="s2">&quot;n_alphas&quot;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span>
                    <span class="s2">&quot;tol&quot;</span><span class="p">:</span> <span class="mf">1e-2</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="n">regmodel</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">ElasticNetCV</span><span class="p">(</span><span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">)</span>
            <span class="n">regmodel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xhat</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_type</span> <span class="o">==</span> <span class="s2">&quot;RidgeCV&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">:</span>  <span class="c1"># if empty dictionary</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alphas&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)}</span>
            <span class="n">regmodel</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">RidgeCV</span><span class="p">(</span><span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">)</span>
            <span class="n">regmodel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xhat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_type</span> <span class="o">==</span> <span class="s2">&quot;OmpCV&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">:</span>  <span class="c1"># if empty dictionary</span>
                <span class="k">pass</span>
            <span class="n">regmodel</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">OrthogonalMatchingPursuitCV</span><span class="p">(</span>
                <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span>
            <span class="p">)</span>
            <span class="n">regmodel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xhat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_type</span> <span class="o">!=</span> <span class="s2">&quot;quadrature&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coef</span> <span class="o">=</span> <span class="n">regmodel</span><span class="o">.</span><span class="n">coef_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coef_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coef</span>  <span class="c1"># backwards comaptible with sklearn API</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_importances_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_importances</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_phi</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xhat</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">sensitivity_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">coef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Must run fit or feed in coef array.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">computeSobol</span><span class="p">()</span>

<div class="viewcode-block" id="PCEReg.feature_importances"><a class="viewcode-back" href="../../api2.html#tesuract.PCEReg.feature_importances">[docs]</a>    <span class="k">def</span> <span class="nf">feature_importances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute feature importances which are equivalent to the normalized Sobol total order sensitivity indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        feature_importances_    : numpy.ndarray of shape (dim,)</span>

<span class="sd">            array representing normalized Sobol total order indices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">computeSobol</span><span class="p">())</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_importances_</span> <span class="o">=</span> <span class="n">S</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_importances_</span></div>

<div class="viewcode-block" id="PCEReg.joint_effects"><a class="viewcode-back" href="../../api2.html#tesuract.PCEReg.joint_effects">[docs]</a>    <span class="k">def</span> <span class="nf">joint_effects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Sobol joint effect sensitivity indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        joint_effects_    : numpy.ndarray of shape (dim,dim)</span>

<span class="sd">            the lower triangular part of the array contains the joint effect sensitivity indices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">S2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computeJointSobol</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">joint_effects_</span> <span class="o">=</span> <span class="n">S2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">joint_effects_</span></div>

    <span class="k">def</span> <span class="nf">multiindex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Must run fit or feed in mindex array.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_M</span>

<div class="viewcode-block" id="PCEReg.predict"><a class="viewcode-back" href="../../api2.html#tesuract.PCEReg.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        After fitting, evaluates the polynomial for a single feature space sample or array of samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        X       : numpy.ndarray of shape (nsamples, dim)</span>

<span class="sd">                Samples to evaluate the fit polynomial. Must have self.coef\_ set or defined already. Can take 1d or 2d array of samples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        y       : numpy.ndarray of shape (nsamples,)</span>

<span class="sd">                Returns the scalar array of polynomial evaluations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check_is_fitted(self)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="c1"># self._fit_transform(X)</span>
        <span class="c1"># Phi = check_array(self._Phi)</span>
        <span class="c1"># ypred = np.dot(Phi,self.coef)</span>
        <span class="n">ypred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyeval</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ypred</span></div></div>


<span class="c1"># In development</span>
<span class="k">class</span> <span class="nc">PCESeries</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">MIs</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="p">[],</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># construct series of pce&#39;s</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">MIs</span><span class="p">),</span> <span class="s2">&quot;coef and multindex mismatch!&quot;</span>
        <span class="c1"># add assert for single array</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># assign simple index as time</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">C</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MIs</span> <span class="o">=</span> <span class="n">MIs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="c1"># construct PCEs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constructPCEs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__constructPCEs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PCEs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="n">pcetemp</span> <span class="o">=</span> <span class="n">PCEBuilder</span><span class="p">(</span>
                <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">customM</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MIs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PCEs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pcetemp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="s2">&quot;dimension mismatch!&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="n">ytemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PCEs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ytemp</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">ieval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="c1"># each element of T can be a vector</span>
        <span class="c1"># first evaluate all PCEs at X points</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="c1"># interpolate for each time point</span>
        <span class="n">T1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">T1d</span><span class="p">),</span> <span class="s2">&quot;time and X mismatch!&quot;</span>
        <span class="n">Yi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">T1d</span><span class="p">)):</span>
            <span class="n">yitemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">T1d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">Yi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">yitemp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Yi</span><span class="p">)</span>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By K. Chowdhary<br/>
  
      &copy; Copyright 2021, K. Chowdhary.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>